<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Kollision Vision | HUD</title>
    
    <!-- PWA Identity -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- 1. UI & Audio -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- 2. AI Engines (Local) -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        /* Automotive HUD Styling */
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

        body { 
            background-color: #000; 
            color: #fff; 
            font-family: 'JetBrains Mono', monospace; 
            overflow: hidden; 
            touch-action: none;
        }

        /* Full Screen Video Layer */
        #monitor-container {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 0;
            overflow: hidden;
        }
        
        #video-feed { display: none; }
        
        #canvas-feed { 
            width: 100%; height: 100%; 
            object-fit: cover; /* Immersive fill */
            transform: scaleX(1); /* Default Road mode */
        }

        /* Glassmorphism HUD Overlays */
        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px;
            pointer-events: auto;
        }

        /* Top Bar */
        .hud-top {
            position: absolute; top: 16px; left: 16px; right: 16px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through gaps */
        }

        /* Bottom Bar */
        .hud-bottom {
            position: absolute; bottom: 24px; left: 16px; right: 16px;
            display: flex; justify-content: space-between; align-items: flex-end;
            z-index: 10;
            pointer-events: none;
        }

        /* Critical Alert Overlay */
        #alert-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            box-shadow: inset 0 0 0 0 transparent;
            transition: box-shadow 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .alert-critical { box-shadow: inset 0 0 100px rgba(239, 68, 68, 0.8) !important; border: 8px solid #ef4444; }
        .alert-warning { box-shadow: inset 0 0 60px rgba(234, 179, 8, 0.6) !important; border: 8px solid #eab308; }

        /* Big Central Alert Text */
        #risk-message {
            font-size: 3rem; font-weight: 800; text-transform: uppercase;
            text-shadow: 0 0 20px black; opacity: 0; transition: opacity 0.2s;
        }

        /* Install Button Pulse */
        @keyframes pulse-btn { 0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); } }
        .install-pulse { animation: pulse-btn 2s infinite; }

        /* Recording Dot */
        .rec-dot { width: 10px; height: 10px; background: #ef4444; border-radius: 50%; display: inline-block; margin-right: 6px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* Mode Toggles */
        .mode-btn { 
            background: rgba(255,255,255,0.1); 
            color: #9ca3af; 
            border: 1px solid rgba(255,255,255,0.1);
            padding: 8px 16px; border-radius: 8px; font-weight: bold; font-size: 0.9rem;
            margin-right: 8px; cursor: pointer; pointer-events: auto;
        }
        .mode-active { background: #3b82f6; color: white; border-color: #3b82f6; box-shadow: 0 0 15px rgba(59,130,246,0.5); }

    </style>
</head>
<body>

<!-- Immersive Video Background -->
<div id="monitor-container">
    <video id="video-feed" autoplay playsinline muted></video>
    <canvas id="canvas-feed" width="640" height="480"></canvas>
    
    <!-- Full Screen Alert Borders -->
    <div id="alert-overlay">
        <div id="risk-message">COLLISION</div>
    </div>
</div>

<!-- HUD Top Layer -->
<div class="hud-top">
    <!-- Status Panel -->
    <div class="hud-panel flex flex-col gap-1">
        <div class="flex items-center gap-2">
            <span class="text-xs text-gray-400">FPS</span>
            <span id="fps-counter" class="text-green-400 font-bold">0</span>
        </div>
        <div class="flex items-center gap-2">
            <span class="text-xs text-gray-400">SYS</span>
            <span id="aux-status" class="text-cyan-400 font-bold text-xs">Scanning</span>
        </div>
        <div id="rec_indicator" class="hidden items-center mt-1">
            <div class="rec-dot"></div> <span class="text-xs text-red-500 font-bold">REC</span>
        </div>
    </div>

    <!-- Actions Panel (Install, Flip Cam) -->
    <div class="flex gap-2 pointer-events-auto">
        <!-- Install Button (Hidden by default, shown via JS on Android) -->
        <button id="install-btn" class="hidden bg-blue-600 text-white p-3 rounded-xl install-pulse shadow-lg" onclick="window.installApp()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
        </button>
        
        <!-- iOS Help Button -->
        <button id="ios-help-btn" class="hidden bg-gray-700 text-white p-3 rounded-xl shadow-lg" onclick="document.getElementById('ios-modal').classList.remove('hidden')">
            <span class="font-bold text-lg">?</span>
        </button>

        <!-- Camera Flip -->
        <button class="bg-gray-800/80 backdrop-blur text-white p-3 rounded-xl border border-gray-600" onclick="window.toggleCamera()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        </button>
    </div>
</div>

<!-- HUD Bottom Layer -->
<div class="hud-bottom">
    <!-- Mode Switcher -->
    <div class="pointer-events-auto flex">
        <button id="btn-road" class="mode-btn mode-active" onclick="window.switchMode('road')">ROAD</button>
        <button id="btn-driver" class="mode-btn" onclick="window.switchMode('driver')">DRIVER</button>
    </div>

    <!-- Speed & TTC (The Dashboard) -->
    <div class="hud-panel flex gap-6 text-right">
        <div>
            <div class="text-[10px] text-gray-400 uppercase">TTC</div>
            <div id="closest-ttc" class="text-3xl font-bold">--</div>
        </div>
        <div>
            <div class="text-[10px] text-gray-400 uppercase">SPEED</div>
            <div class="text-3xl font-bold text-yellow-400"><span id="closest-speed">0</span> <span class="text-sm text-gray-500">MPH</span></div>
        </div>
    </div>
</div>

<!-- iOS Install Instructions Modal -->
<div id="ios-modal" class="hidden fixed inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6 text-center">
    <h2 class="text-2xl font-bold text-blue-400 mb-4">Install App</h2>
    <p class="text-gray-300 mb-6">To install this app on your iPhone:</p>
    <div class="bg-gray-800 p-4 rounded-lg text-left text-sm space-y-3 mb-6 w-full max-w-sm">
        <p>1. Tap the <b>Share</b> button <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Apple_Share_icon.svg/1200px-Apple_Share_icon.svg.png" class="inline w-4 h-4 invert"> below.</p>
        <p>2. Scroll down and tap <b>Add to Home Screen</b>.</p>
    </div>
    <button class="bg-blue-600 px-6 py-3 rounded-lg font-bold w-full max-w-sm" onclick="document.getElementById('ios-modal').classList.add('hidden')">Got it</button>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- PWA LOGIC ---
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault(); deferredPrompt = e;
        document.getElementById('install-btn').classList.remove('hidden');
    });
    window.installApp = async () => {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            if (outcome === 'accepted') { deferredPrompt = null; document.getElementById('install-btn').classList.add('hidden'); }
        }
    };
    const isIos = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
    if (isIos && !isStandalone) document.getElementById('ios-help-btn').classList.remove('hidden');

    // --- CONFIGURATION ---
    const MODEL_PATH = './yolov8n.onnx';
    const YOLO_SIZE = 640; 
    const DISPLAY_W = 640; 
    const DISPLAY_H = 480;
    const CONFIDENCE_THRESHOLD = 0.25; 
    const IOU_THRESHOLD = 0.45;
    const TARGET_FPS = 15; 
    let TTC_THRESHOLDS = { CRITICAL: 1.5, WARNING: 3.0 };
    const EAR_THRESHOLD = 0.25; 
    const SLEEP_FRAMES = 20;
    const LABELS = ["person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat", "traffic light", "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep", "cow", "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella", "handbag", "tie", "suitcase", "frisbee", "skis", "snowboard", "sports ball", "kite", "baseball bat", "baseball glove", "skateboard", "surfboard", "tennis racket", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple", "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair", "couch", "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse", "remote", "keyboard", "cell phone", "microwave", "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear", "hair drier", "toothbrush"];

    // --- STATE ---
    let currentMode = 'road';
    let currentFacingMode = 'environment';
    let session = null;
    let faceMesh = null;
    let faceMeshLoading = false; 
    let isProcessing = false;
    let lastTime = 0;
    let cvLoaded = false;
    let audioCtx = null;
    let firebaseReady = false, db, auth, userId;
    
    const float32Data = new Float32Array(3 * YOLO_SIZE * YOLO_SIZE);
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = YOLO_SIZE; tempCanvas.height = YOLO_SIZE;
    const tempCtx = tempCanvas.getContext('2d');
    let scaleFactor=1, xOffset=0, yOffset=0;

    let lastDetections = [];
    let frameCount = 0;
    let lastFpsTime = performance.now();
    let recorder = null;

    // --- DOM ---
    const video = document.getElementById('video-feed');
    const canvas = document.getElementById('canvas-feed');
    const ctx = canvas.getContext('2d');
    const ttcEl = document.getElementById('closest-ttc'); 
    const speedEl = document.getElementById('closest-speed');
    const auxEl = document.getElementById('aux-status');
    const fpsCounterEl = document.getElementById('fps-counter');
    const alertOverlay = document.getElementById('alert-overlay');
    const riskMessage = document.getElementById('risk-message');
    const recIndicator = document.getElementById('rec_indicator');
    const cameraErrorEl = document.getElementById('camera-error');

    // --- FEATURE 1: INCIDENT RECORDER ---
    class IncidentRecorder {
        constructor() { this.mediaRecorder = null; this.chunks = []; this.isRecording = false; this.cooldown = false; }
        start() {
            if (this.isRecording || this.cooldown) return;
            if (!canvas.captureStream) return;
            const stream = canvas.captureStream(30);
            try { this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); } catch (e) { return; } 
            this.mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) this.chunks.push(e.data); };
            this.mediaRecorder.onstop = () => this.save();
            this.mediaRecorder.start();
            this.isRecording = true;
            recIndicator.classList.remove('hidden'); recIndicator.classList.add('flex');
            setTimeout(() => this.stop(), 5000); 
        }
        stop() {
            if (this.isRecording) { this.mediaRecorder.stop(); this.isRecording = false; recIndicator.classList.add('hidden'); recIndicator.classList.remove('flex'); }
        }
        save() {
            const blob = new Blob(this.chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `incident_${Date.now()}.webm`; a.click();
            this.chunks = []; this.cooldown = true; setTimeout(() => this.cooldown = false, 10000); 
        }
        trigger(risk) { if (risk === 'Critical') this.start(); }
    }

    // --- FEATURE 2: LANE TRACKER ---
    class LaneTracker {
        constructor() { this.ready = false; this.src = null; this.dst = null; this.lines = null; }
        init() {
            if (typeof cv !== 'undefined' && cv.Mat) {
                this.src = new cv.Mat(DISPLAY_H, DISPLAY_W, cv.CV_8UC4);
                this.dst = new cv.Mat(DISPLAY_H, DISPLAY_W, cv.CV_8UC1);
                this.lines = new cv.Mat();
                this.ready = true;
            }
        }
        detect(canvasCtx) {
            if (!this.ready) return "Loading...";
            try {
                const imgData = canvasCtx.getImageData(0, 0, DISPLAY_W, DISPLAY_H);
                this.src.data.set(imgData.data);
                cv.cvtColor(this.src, this.dst, cv.COLOR_RGBA2GRAY, 0);
                cv.Canny(this.dst, this.dst, 50, 200, 3, false);
                let rect = new cv.Rect(0, DISPLAY_H/2, DISPLAY_W, DISPLAY_H/2);
                let roi = this.dst.roi(rect);
                cv.HoughLinesP(roi, this.lines, 1, Math.PI / 180, 30, 30, 20);
                let status = "No Lanes"; 
                let leftLines = [], rightLines = [];
                if (this.lines.rows > 0) {
                    for (let i = 0; i < this.lines.rows; ++i) {
                        let x1 = this.lines.data32S[i * 4]; let y1 = this.lines.data32S[i * 4 + 1] + DISPLAY_H/2;
                        let x2 = this.lines.data32S[i * 4 + 2]; let y2 = this.lines.data32S[i * 4 + 3] + DISPLAY_H/2;
                        const slope = (y2 - y1) / (x2 - x1);
                        if (slope < -0.3 && slope > -5) leftLines.push({slope, x1, y1, x2, y2});
                        else if (slope > 0.3 && slope < 5) rightLines.push({slope, x1, y1, x2, y2});
                    }
                    const drawAvgLine = (lines) => {
                        if (lines.length === 0) return false;
                        let avgSlope = 0, avgX = 0, avgY = 0, count = 0;
                        lines.forEach(l => { avgSlope += l.slope; avgX += (l.x1 + l.x2)/2; avgY += (l.y1 + l.y2)/2; count++; });
                        avgSlope /= count; avgX /= count; avgY /= count;
                        const intercept = avgY - (avgSlope * avgX);
                        const yBottom = DISPLAY_H; const yTop = DISPLAY_H * 0.6;
                        const xBottom = (yBottom - intercept) / avgSlope; const xTop = (yTop - intercept) / avgSlope;
                        canvasCtx.beginPath(); canvasCtx.moveTo(xBottom, yBottom); canvasCtx.lineTo(xTop, yTop);
                        canvasCtx.lineWidth = 6; canvasCtx.strokeStyle = 'rgba(6, 182, 212, 0.8)'; 
                        canvasCtx.lineCap = 'round'; canvasCtx.shadowBlur = 15; canvasCtx.shadowColor = 'cyan';
                        canvasCtx.stroke(); canvasCtx.shadowBlur = 0;
                        return true;
                    };
                    const hasLeft = drawAvgLine(leftLines); const hasRight = drawAvgLine(rightLines);
                    if (hasLeft && hasRight) status = "Center"; else if (hasLeft) status = "Drift Right"; else if (hasRight) status = "Drift Left"; 
                } else {
                    canvasCtx.save(); canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; canvasCtx.lineWidth = 2;
                    canvasCtx.setLineDash([10, 10]); canvasCtx.strokeRect(20, DISPLAY_H/2 + 20, DISPLAY_W-40, DISPLAY_H/2 - 40); canvasCtx.restore();
                }
                roi.delete(); return status;
            } catch(e) { return "CV Error"; }
        }
    }
    const laneTracker = new LaneTracker();
    function checkOpenCV() { if (typeof cv !== 'undefined' && cv.Mat) { cvLoaded = true; laneTracker.init(); } else { setTimeout(checkOpenCV, 100); } }
    checkOpenCV();

    // --- FEATURE 3: DROWSINESS ---
    class DrowsinessTracker {
        constructor() { this.closedFrameCount = 0; }
        dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
        getEAR(eye) { const A = this.dist(eye[1], eye[5]); const B = this.dist(eye[2], eye[4]); const C = this.dist(eye[0], eye[3]); return (A + B) / (2.0 * C); }
        process(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return { status: "Scanning", alert: false, val: 0 };
            const lm = results.multiFaceLandmarks[0];
            const leftIndices = [33, 160, 158, 133, 153, 144]; const rightIndices = [362, 385, 387, 263, 373, 380];
            const leftEye = leftIndices.map(i => lm[i]); const rightEye = rightIndices.map(i => lm[i]);
            const avgEAR = (this.getEAR(leftEye) + this.getEAR(rightEye)) / 2.0;
            if (avgEAR < EAR_THRESHOLD) this.closedFrameCount++; else this.closedFrameCount = 0;
            if (this.closedFrameCount > SLEEP_FRAMES) return { status: "WAKE UP!", alert: true, val: avgEAR };
            return { status: "Awake", alert: false, val: avgEAR };
        }
    }
    const drowsyTracker = new DrowsinessTracker();

    // --- MATH ---
    class RiskSmoother {
        constructor(historyLen = 2) { this.history = []; this.historyLen = historyLen; this.riskMap = { 'Safe': 0, 'Warning': 1, 'Critical': 2 }; this.revMap = { 0: 'Safe', 1: 'Warning', 2: 'Critical' }; }
        update(currentRisk) { this.history.push(this.riskMap[currentRisk]); if (this.history.length > this.historyLen) this.history.shift(); const maxRiskVal = Math.max(...this.history); return this.revMap[maxRiskVal]; }
    }
    const smoother = new RiskSmoother();
    class ObjectTracker {
        constructor() { this.lastHeight = 0; this.lastTime = 0; }
        calculateTTC(box, timestamp) {
            const h = box[3]; let ttc = 999.0; let risk = 'Safe';
            if (this.lastTime > 0) {
                const dt = (timestamp/1000) - (this.lastTime/1000);
                if (dt > 0.001) {
                    const dh = h - this.lastHeight;
                    if (dh > 0) { const rate = dh/dt; ttc = h / rate; if (ttc < TTC_THRESHOLDS.CRITICAL) risk = 'Critical'; else if (ttc < TTC_THRESHOLDS.WARNING) risk = 'Warning'; }
                }
            }
            this.lastHeight = h; this.lastTime = timestamp / 1000;
            return { ttc, risk };
        }
    }
    const tracker = new ObjectTracker();
    function playBeep(riskLevel) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (riskLevel === 'Critical') { osc.frequency.value = 800; osc.type = 'square'; gain.gain.value = 0.1; osc.start(); osc.stop(audioCtx.currentTime + 0.1); } 
        else if (riskLevel === 'Warning') { osc.frequency.value = 400; osc.type = 'sine'; gain.gain.value = 0.1; osc.start(); osc.stop(audioCtx.currentTime + 0.2); }
    }

    // --- PROCESSING LOOP ---
    function preprocess(ctx, vw, vh) {
        scaleFactor = Math.min(YOLO_SIZE / vw, YOLO_SIZE / vh);
        const newWidth = vw * scaleFactor; const newHeight = vh * scaleFactor;
        xOffset = (YOLO_SIZE - newWidth) / 2; yOffset = (YOLO_SIZE - newHeight) / 2;
        tempCtx.fillStyle = "black"; tempCtx.fillRect(0, 0, YOLO_SIZE, YOLO_SIZE);
        tempCtx.drawImage(video, xOffset, yOffset, newWidth, newHeight);
        const imageData = tempCtx.getImageData(0, 0, YOLO_SIZE, YOLO_SIZE);
        const { data } = imageData; const totalPixels = YOLO_SIZE * YOLO_SIZE;
        for (let i = 0; i < totalPixels; i++) { float32Data[i] = data[i * 4] / 255.0; float32Data[i + totalPixels] = data[i * 4 + 1] / 255.0; float32Data[i + 2 * totalPixels] = data[i * 4 + 2] / 255.0; }
        return new ort.Tensor('float32', float32Data, [1, 3, YOLO_SIZE, YOLO_SIZE]);
    }
    function iou(box1, box2) {
        const [x1, y1, w1, h1] = box1; const [x2, y2, w2, h2] = box2; const xi1 = Math.max(x1, x2); const yi1 = Math.max(y1, y2);
        const xi2 = Math.min(x1 + w1, x2 + w2); const yi2 = Math.min(y1 + h1, y2 + h2);
        const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
        return interArea / ((w1 * h1) + (w2 * h2) - interArea);
    }
    function nms(boxes) {
        if (boxes.length === 0) return []; boxes.sort((a, b) => b.prob - a.prob); const picked = []; const active = new Array(boxes.length).fill(true);
        for (let i = 0; i < boxes.length; i++) { if (!active[i]) continue; const boxA = boxes[i]; picked.push(boxA); for (let j = i + 1; j < boxes.length; j++) { if (!active[j]) continue; if (iou(boxA.box, boxes[j].box) > IOU_THRESHOLD) active[j] = false; } }
        return picked;
    }
    function postprocess(output) {
        const data = output.data; const boxes = []; const num_anchors = 8400; 
        for (let i = 0; i < num_anchors; i++) {
            let maxScore = -Infinity; let maxClass = -1;
            for (let c = 4; c < 84; c++) { const score = data[c * num_anchors + i]; if (score > maxScore) { maxScore = score; maxClass = c - 4; } }
            if (maxScore > CONFIDENCE_THRESHOLD) {
                const x = data[0 * num_anchors + i]; const y = data[1 * num_anchors + i]; const w = data[2 * num_anchors + i]; const h = data[3 * num_anchors + i];
                let x1 = (x - w/2 - xOffset) / scaleFactor; let y1 = (y - h/2 - yOffset) / scaleFactor; let w_scaled = w / scaleFactor; let h_scaled = h / scaleFactor;
                boxes.push({ label: LABELS[maxClass], prob: maxScore, box: [x1, y1, w_scaled, h_scaled] });
            }
        }
        return nms(boxes);
    }

    async function runRoadInference() {
        if (currentMode !== 'road') return;
        // Check if video is actually ready
        if (video.paused || video.ended || video.readyState < 2) {
            requestAnimationFrame(runRoadInference);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        ctx.drawImage(video, 0, 0, DISPLAY_W, DISPLAY_H);
        
        if (cvLoaded) { const laneStatus = laneTracker.detect(ctx); auxEl.innerText = laneStatus; auxEl.style.color = laneStatus === "No Lanes" ? "#fbbf24" : "#22d3ee"; }

        lastDetections.forEach(d => {
            const [x, y, w, h] = d.box;
            let color = d.risk === 'Critical' ? '#ef4444' : d.risk === 'Warning' ? '#eab308' : '#22c55e';
            ctx.strokeStyle = color; ctx.lineWidth = 3;
            const len = Math.min(w, h) * 0.2;
            ctx.beginPath(); ctx.moveTo(x, y + len); ctx.lineTo(x, y); ctx.lineTo(x + len, y); ctx.moveTo(x + w - len, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + len); ctx.moveTo(x, y + h - len); ctx.lineTo(x, y + h); ctx.lineTo(x + len, y + h); ctx.moveTo(x + w - len, y + h); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w, y + h - len); ctx.stroke();
            ctx.font = "bold 14px JetBrains Mono"; ctx.fillStyle = color; ctx.fillText(d.label.toUpperCase(), x + 5, y - 8);
        });

        const now = performance.now();
        if (!isProcessing && (now - lastTime > (1000 / TARGET_FPS))) {
            isProcessing = true; lastTime = now;
            try {
                const inputTensor = preprocess(video, video.videoWidth, video.videoHeight);
                const feeds = {}; feeds[session.inputNames[0]] = inputTensor;
                const results = await session.run(feeds);
                const output = results[session.outputNames[0]];
                const boxes = postprocess(output);
                let primaryBox = null; let maxArea = 0;
                boxes.forEach(d => { const [x, y, w, h] = d.box; if (w*h > maxArea) { maxArea=w*h; primaryBox=d.box; } });
                let currentTTC = 999.0; let currentRisk = 'Safe'; let speedMph = 0.0;
                if (primaryBox) {
                    const res = tracker.calculateTTC(primaryBox, now); currentTTC = res.ttc; currentRisk = res.risk;
                    const expansionRate = (primaryBox[3] - tracker.lastHeight) / ((now - tracker.lastTime*1000)/1000);
                    if (expansionRate > 0) speedMph = expansionRate * 2.0;
                } else { tracker.lastHeight = 0; }
                const finalRisk = smoother.update(currentRisk);
                if (recorder) recorder.trigger(finalRisk);
                boxes.forEach(b => b.risk = finalRisk);
                lastDetections = boxes;
                ttcEl.innerText = currentTTC >= 900 ? "--" : currentTTC.toFixed(1);
                speedEl.innerText = Math.round(speedMph);
                alertOverlay.className = ''; riskMessage.style.opacity = 0;
                if (finalRisk === 'Critical') { alertOverlay.className = 'alert-critical'; riskMessage.innerText = "COLLISION"; riskMessage.style.color = "#ef4444"; riskMessage.style.opacity = 1; playBeep('Critical'); } 
                else if (finalRisk === 'Warning') { alertOverlay.className = 'alert-warning'; riskMessage.innerText = "WARNING"; riskMessage.style.color = "#eab308"; riskMessage.style.opacity = 1; playBeep('Warning'); }
            } catch(e) { console.error("Road inference error", e); } finally { isProcessing = false; }
        }
        frameCount++; if (performance.now() - lastFpsTime >= 1000) { fpsCounterEl.innerText = frameCount; frameCount = 0; lastFpsTime = performance.now(); }
        
        // Loop safety: only loop if we are still in road mode
        if (currentMode === 'road') requestAnimationFrame(runRoadInference);
    }

    // --- FIX: ROBUST DRIVER MODE INITIALIZATION & LOOP ---
    async function initFaceMesh() {
        if (faceMesh) return; // Already ready
        if (faceMeshLoading) return; // Already initializing, wait
        
        faceMeshLoading = true;
        auxEl.innerText = "Loading AI...";
        
        try {
            const fm = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            fm.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            fm.onResults(onFaceResults);
            
            await fm.initialize();
            
            faceMesh = fm; // Assign only after full init
            auxEl.innerText = "Active";
        } catch (e) {
            console.error("FaceMesh Init Error", e);
            auxEl.innerText = "Error";
            faceMeshLoading = false; // Reset to allow retry
        }
    }

    function onFaceResults(results) {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        ctx.restore();
        const result = drowsyTracker.process(results);
        ttcEl.innerText = result.val ? result.val.toFixed(2) : '--'; 
        auxEl.innerText = "Tracking";
        alertOverlay.className = ''; riskMessage.style.opacity = 0;
        if (result.alert) { alertOverlay.className = 'alert-critical'; riskMessage.innerText = "WAKE UP!"; riskMessage.style.color = "#ef4444"; riskMessage.style.opacity = 1; playBeep('Critical'); }
    }

    // --- FIX: ROBUST DRIVER LOOP WITH TIMEOUT ---
    async function runDriverInference() {
        if (currentMode !== 'driver') return;
        
        // Wait for Video AND AI Model to be ready
        if (!faceMesh || video.paused || video.ended || video.readyState < 2 || video.videoWidth === 0) {
            // FIX: If AI not ready, draw video stream directly to avoid black screen freeze
            if (!faceMesh) {
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                ctx.restore();
                ctx.font = "20px monospace"; ctx.fillStyle = "yellow"; ctx.fillText("Loading AI...", 20, 40);
            }
            requestAnimationFrame(runDriverInference);
            return;
        }

        try {
            // RACE: 100ms timeout prevents loop from hanging if FaceMesh is slow
            const timeout = new Promise((_, reject) => setTimeout(() => reject('timeout'), 100));
            await Promise.race([faceMesh.send({image: video}), timeout]);
        } catch (e) {
            // Ignore timeouts, just skip frame
            if (e !== 'timeout') console.error("Driver Loop Error", e);
        }
        
        if (currentMode === 'driver') requestAnimationFrame(runDriverInference);
    }

    // --- CAMERA & MODES ---
    async function startCamera() {
        if (video.srcObject) {
            video.srcObject.getTracks().forEach(t => t.stop());
            video.srcObject = null;
        }
        
        const constraints = { 
            video: { 
                width: { ideal: DISPLAY_W }, 
                height: { ideal: DISPLAY_H }, 
                facingMode: currentFacingMode 
            } 
        };
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            
            // Wait for data to actually load before starting loops
            video.onloadeddata = async () => {
                try {
                    await video.play();
                    // Clear any previous loops logic implicitly by the `currentMode` check in loops
                    if (currentMode === 'road') {
                        canvas.style.transform = "scaleX(1)";
                        runRoadInference();
                    } else {
                        canvas.style.transform = "scaleX(-1)";
                        initFaceMesh(); // Remove await so we enter loop instantly
                        runDriverInference();
                    }
                } catch(e) { console.error("Play error", e); }
            };
        } catch (err) {
            console.error(err);
            if (location.protocol === 'http:' && location.hostname !== 'localhost') {
                 alert("Camera Blocked! Use HTTPS.");
            }
        }
    }

    window.switchMode = async function(mode) {
        if (currentMode === mode) return; // Debounce
        currentMode = mode;
        document.getElementById('btn-road').className = mode === 'road' ? 'mode-btn flex-1 mode-active' : 'mode-btn flex-1';
        document.getElementById('btn-driver').className = mode === 'driver' ? 'mode-btn flex-1 mode-active' : 'mode-btn flex-1';
        
        // Clear canvas while switching
        ctx.clearRect(0,0,canvas.width,canvas.height);
        auxEl.innerText = "Switching...";
        
        currentFacingMode = mode === 'road' ? 'environment' : 'user';
        await startCamera();
    }

    window.toggleCamera = async function() {
        currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
        await startCamera();
    }

    // --- INITIALIZATION ---
    async function main() {
        try {
            auxEl.innerText = "Loading AI...";
            const resp = await fetch(MODEL_PATH);
            if (!resp.ok) throw new Error("yolov8n.onnx not found!");
            
            if (typeof ort === 'undefined') throw new Error("ONNX Failed");
            ort.env.logLevel = 'error';
            session = await ort.InferenceSession.create(MODEL_PATH, { executionProviders: ['wasm'] });
            
            recorder = new IncidentRecorder();
            window.switchMode('road');

        } catch (e) {
            auxEl.innerText = "Error"; console.error(e);
        }
    }
    
    // --- FIREBASE ---
    window.setupFirebase = async function() {
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = {}; try { firebaseConfig = JSON.parse(__firebase_config); } catch {}
        if (firebaseConfig.projectId) {
            const app = initializeApp(firebaseConfig); db = getFirestore(app); auth = getAuth(app);
            try { await signInAnonymously(auth); 
                onAuthStateChanged(auth, (u) => { if(u) { 
                    userId=u.uid;
                    onSnapshot(doc(db, `artifacts/${appId}/users/${userId}/settings`, 'adas_config'), (snap) => {
                        if (snap.exists()) {
                            const s = snap.data();
                            TTC_THRESHOLDS.CRITICAL = s.critical_ttc;
                            TTC_THRESHOLDS.WARNING = s.warning_ttc;
                        }
                    });
                } });
            } catch (e) {}
        }
    }

    document.addEventListener('DOMContentLoaded', () => { window.setupFirebase(); window.onload = main; });

</script>
</body>
</html>
