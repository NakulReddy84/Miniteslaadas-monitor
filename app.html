<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kollision Vision | Monitor</title>
    
    <!-- PWA Identity -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    
    <!-- SECURITY: Force HTTPS (Required for Camera) -->
    <script>
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            location.replace(`https:${location.href.substring(location.protocol.length)}`);
        }
    </script>
    
    <!-- 1. UI & Audio -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- 2. AI Engines (Local) -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    
    <!-- FIX: Removed 'onload' to prevent ReferenceError. We use polling in JS instead. -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" type="text/javascript"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body { background-color: #1f2937; color: #f3f4f6; font-family: 'Inter', sans-serif; }
        .container { max-width: 1200px; margin: auto; padding: 2rem; }
        .monitor-area { 
            position: relative; background-color: #0f172a; border-radius: 1rem; overflow: hidden; 
            aspect-ratio: 4/3; display: flex; justify-content: center; align-items: center; border: 1px solid #374151;
        }
        #video-feed { display: none; }
        /* Canvas scales to fit container, AI uses internal resolution */
        #canvas-feed { width: 100%; height: 100%; display: block; object-fit: contain; }
        
        .status-box { background-color: #374151; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; }
        
        /* Alerts */
        #risk-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 1rem 2rem; border-radius: 1rem; font-size: 2.5rem; font-weight: 900;
            text-align: center; z-index: 20; opacity: 0; transition: opacity 0.1s ease;
            pointer-events: none; width: 90%; max-width: 800px; text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        .risk-warning { color: #fcd34d; border: 5px solid #d97706; background-color: rgba(251, 191, 36, 0.3); }
        .risk-critical { color: #fee2e2; border: 8px solid #b91c1c; background-color: rgba(239, 68, 68, 0.7); }
        
        #rec_indicator {
            position: absolute; top: 20px; right: 20px;
            background-color: rgba(239, 68, 68, 0.9); color: white;
            padding: 5px 12px; border-radius: 20px; font-size: 12px; font-weight: bold;
            display: none; align-items: center; gap: 6px; z-index: 101;
        }
        .rec-dot { width: 8px; height: 8px; background: white; border-radius: 50%; animation: blink 1s infinite; }
        
        .mode-btn { background: #374151; padding: 8px; border-radius: 6px; font-size: 12px; font-weight: bold; width: 48%; transition: background 0.2s; }
        .mode-btn:hover { background: #4b5563; }
        .mode-active { background: #3b82f6 !important; color: white; }

        .lane-drift-border { border-color: #06b6d4 !important; box-shadow: 0 0 15px cyan; }
        .critical-border { border-color: red !important; box-shadow: 0 0 15px red; }
        
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div class="container flex flex-col lg:flex-row gap-8">
    <div class="lg:w-3/4 monitor-area" id="monitor-container">
        <!-- Added muted/playsinline to ensure autoplay works on mobile -->
        <video id="video-feed" autoplay playsinline muted></video>
        <canvas id="canvas-feed" width="640" height="480"></canvas>
        <div id="risk-message" class="transition-all duration-300"></div>
        <div id="rec_indicator"><div class="rec-dot"></div> REC EVIDENCE</div>
    </div>
    
    <div class="lg:w-1/4 flex flex-col gap-4">
        <h1 class="text-3xl font-extrabold text-blue-400 mb-2">KAIROS Hybrid</h1>
        
        <div class="flex justify-between mb-2">
            <!-- FIXED: Added 'mode-active' class to match CSS and fixed IDs to match JS -->
            <button id="btn-road" class="mode-btn mode-active" onclick="window.switchMode('road')">üõ£Ô∏è ROAD</button>
            <button id="btn-driver" class="mode-btn" onclick="window.switchMode('driver')">üò¥ DRIVER</button>
        </div>

        <div class="status-box">
            <h2 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-1">Status</h2>
            <p id="system-status" class="text-yellow-400 font-bold">Initializing...</p>
            <div class="flex justify-between mt-2 text-xs text-gray-500">
                <span>FPS: <span id="fps-counter" class="text-white">0</span></span>
                <span>User: <span id="user-id-display">Local</span></span>
            </div>
        </div>

        <div class="status-box">
            <h2 class="text-xs font-bold text-red-400 uppercase tracking-wider mb-2">Telemetry</h2>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <p class="text-xs text-gray-500">TTC</p>
                    <p id="closest-ttc" class="text-xl font-mono font-bold text-white">--</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">Speed</p>
                    <p id="closest-speed" class="text-xl font-mono font-bold text-white">--</p>
                </div>
            </div>
            <div class="mt-2 flex justify-between">
                <div>
                    <p class="text-xs text-gray-500">Alert</p>
                    <p id="closest-risk" class="text-lg font-bold text-green-500">Safe</p>
                </div>
                <div class="text-right">
                    <p class="text-xs text-gray-500">Lane / Eye</p>
                    <p id="aux-status" class="text-sm font-bold text-cyan-400">Scanning</p>
                </div>
            </div>
        </div>

        <div class="status-box">
            <h2 class="text-xs font-bold text-blue-400 uppercase tracking-wider mb-2">Configuration</h2>
            <div class="space-y-2">
                <div class="flex justify-between items-center">
                    <label class="text-sm text-red-300">Critical (s)</label>
                    <input type="number" id="critical-input" value="5.0" step="0.5" class="w-16 bg-gray-900 text-white p-1 rounded text-right border border-gray-600">
                </div>
                <div class="flex justify-between items-center">
                    <label class="text-sm text-yellow-300">Warning (s)</label>
                    <input type="number" id="warning-input" value="10.0" step="0.5" class="w-16 bg-gray-900 text-white p-1 rounded text-right border border-gray-600">
                </div>
            </div>
            <button id="save-settings-btn" class="w-full mt-3 bg-gray-700 hover:bg-gray-600 text-white text-sm font-bold py-2 rounded transition">Update Thresholds</button>
            <p id="save-status-msg" class="text-[10px] text-gray-500 mt-1 text-center">Settings loaded from Cloud.</p>
        </div>
        
        <div class="mt-auto flex flex-col gap-2">
            <button id="start-button" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition mb-2 disabled:opacity-50" disabled>Loading AI...</button>
            <button id="stop-button" class="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow transition disabled:opacity-50" disabled>Stop</button>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- CONFIGURATION ---
    const MODEL_PATH = './yolov8n.onnx';
    const YOLO_SIZE = 640; 
    const DISPLAY_W = 640; 
    const DISPLAY_H = 480;
    const CONFIDENCE_THRESHOLD = 0.25; 
    const IOU_THRESHOLD = 0.45;
    const TARGET_FPS = 15; 
    
    let TTC_THRESHOLDS = { CRITICAL: 1.5, WARNING: 3.0 };
    const EAR_THRESHOLD = 0.25; 
    const SLEEP_FRAMES = 20;

    const LABELS = ["person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat", "traffic light", "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep", "cow", "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella", "handbag", "tie", "suitcase", "frisbee", "skis", "snowboard", "sports ball", "kite", "baseball bat", "baseball glove", "skateboard", "surfboard", "tennis racket", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple", "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair", "couch", "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse", "remote", "keyboard", "cell phone", "microwave", "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear", "hair drier", "toothbrush"];

    // --- STATE ---
    let currentMode = 'road';
    let session = null;
    let faceMesh = null;
    let isProcessing = false;
    let lastTime = 0;
    let cvLoaded = false;
    let audioCtx = null;
    let firebaseReady = false, db, auth, userId;
    
    const float32Data = new Float32Array(3 * YOLO_SIZE * YOLO_SIZE);
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = YOLO_SIZE; tempCanvas.height = YOLO_SIZE;
    const tempCtx = tempCanvas.getContext('2d');
    let scaleFactor=1, xOffset=0, yOffset=0;

    let lastDetections = [];
    let animationFrameId = null;
    let frameCount = 0;
    let lastFpsTime = performance.now();
    
    // FIX: Using 'let' instead of 'const' to avoid assignment error
    let recorder = null;

    // --- DOM ---
    const video = document.getElementById('video-feed');
    const canvas = document.getElementById('canvas-feed');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('start-button');
    const stopButton = document.getElementById('stop-button');
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    const ttcEl = document.getElementById('closest-ttc'); 
    const speedEl = document.getElementById('closest-speed');
    const riskEl = document.getElementById('closest-risk');
    const auxEl = document.getElementById('aux-status');
    const statusTextEl = document.getElementById('system-status');
    const alertEl = document.getElementById('risk-message');
    const recEl = document.getElementById('rec_indicator');
    const monitorContainer = document.getElementById('monitor-container');
    const critInput = document.getElementById('critical-input');
    const warnInput = document.getElementById('warning-input');
    const fpsCounterEl = document.getElementById('fps-counter');
    const objectCountEl = document.getElementById('object-count');
    const userIdDisplay = document.getElementById('user-id-display');
    const saveStatusMsg = document.getElementById('save-status-msg');

    function log(msg) { console.log(msg); }

    // --- FEATURE 1: BLACK BOX RECORDER ---
    class IncidentRecorder {
        constructor() {
            this.mediaRecorder = null; this.chunks = []; this.isRecording = false; this.cooldown = false;
        }
        start() {
            if (this.isRecording || this.cooldown) return;
            // Access global canvas
            const stream = canvas.captureStream(30);
            try { this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); } 
            catch (e) { return; } 
            this.mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) this.chunks.push(e.data); };
            this.mediaRecorder.onstop = () => this.save();
            this.mediaRecorder.start();
            this.isRecording = true;
            recEl.style.display = 'flex';
            setTimeout(() => this.stop(), 5000); 
        }
        stop() {
            if (this.isRecording) {
                this.mediaRecorder.stop();
                this.isRecording = false;
                recEl.style.display = 'none';
            }
        }
        save() {
            const blob = new Blob(this.chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `incident_${Date.now()}.webm`; a.click();
            this.chunks = []; this.cooldown = true; setTimeout(() => this.cooldown = false, 10000); 
        }
        trigger(risk) { if (risk === 'Critical') this.start(); }
    }

    // --- FEATURE 2: LANE DETECTION (OpenCV) ---
    class LaneTracker {
        constructor() { this.ready = false; this.src = null; this.dst = null; this.lines = null; }
        init() {
            if (typeof cv !== 'undefined' && cv.Mat) {
                this.src = new cv.Mat(DISPLAY_H, DISPLAY_W, cv.CV_8UC4);
                this.dst = new cv.Mat(DISPLAY_H, DISPLAY_W, cv.CV_8UC1);
                this.lines = new cv.Mat();
                this.ready = true;
            }
        }
        detect(canvasCtx) {
            if (!this.ready) return "Loading...";
            try {
                const imgData = canvasCtx.getImageData(0, 0, DISPLAY_W, DISPLAY_H);
                this.src.data.set(imgData.data);
                cv.cvtColor(this.src, this.dst, cv.COLOR_RGBA2GRAY, 0);
                cv.Canny(this.dst, this.dst, 50, 200, 3, false);
                // Region of Interest (Bottom half)
                let rect = new cv.Rect(0, DISPLAY_H/2, DISPLAY_W, DISPLAY_H/2);
                let roi = this.dst.roi(rect);
                
                // ADJUSTED PARAMETERS: Lower threshold (30), shorter lines allowed (30), larger gaps allowed (20)
                cv.HoughLinesP(roi, this.lines, 1, Math.PI / 180, 30, 30, 20);
                
                let status = "No Lanes"; // Default if nothing found
                
                if (this.lines.rows > 0) {
                    let left=0, right=0;
                    for (let i = 0; i < this.lines.rows; ++i) {
                        let x1 = this.lines.data32S[i * 4];
                        let y1 = this.lines.data32S[i * 4 + 1] + DISPLAY_H/2;
                        let x2 = this.lines.data32S[i * 4 + 2];
                        let y2 = this.lines.data32S[i * 4 + 3] + DISPLAY_H/2;
                        canvasCtx.beginPath(); canvasCtx.moveTo(x1, y1); canvasCtx.lineTo(x2, y2);
                        canvasCtx.lineWidth = 3; canvasCtx.strokeStyle = 'cyan'; canvasCtx.stroke();
                        if (x1 < DISPLAY_W/2) left++; else right++;
                    }
                    if (left > right + 2) status = "Drift Left"; 
                    else if (right > left + 2) status = "Drift Right";
                    else status = "Center";
                } else {
                    // Visual feedback for scanning even if no lines found
                    canvasCtx.save();
                    canvasCtx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.setLineDash([5, 5]);
                    canvasCtx.strokeRect(10, DISPLAY_H/2 + 10, DISPLAY_W-20, DISPLAY_H/2 - 20);
                    canvasCtx.restore();
                }
                
                roi.delete(); return status;
            } catch(e) { return "CV Error"; }
        }
    }
    const laneTracker = new LaneTracker();
    
    // Polling for OpenCV
    function checkOpenCV() {
        if (typeof cv !== 'undefined' && cv.Mat) {
            cvLoaded = true;
            laneTracker.init();
        } else {
            setTimeout(checkOpenCV, 100);
        }
    }
    checkOpenCV();

    // --- NEW: DROWSINESS TRACKER (Phase 5) ---
    class DrowsinessTracker {
        constructor() { this.closedFrameCount = 0; }
        dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
        getEAR(eye) {
            const A = this.dist(eye[1], eye[5]);
            const B = this.dist(eye[2], eye[4]);
            const C = this.dist(eye[0], eye[3]);
            return (A + B) / (2.0 * C);
        }
        process(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return { status: "No Face", alert: false, val: 0 };
            const lm = results.multiFaceLandmarks[0];
            const leftIndices = [33, 160, 158, 133, 153, 144];
            const rightIndices = [362, 385, 387, 263, 373, 380];
            const leftEye = leftIndices.map(i => lm[i]);
            const rightEye = rightIndices.map(i => lm[i]);
            const avgEAR = (this.getEAR(leftEye) + this.getEAR(rightEye)) / 2.0;

            if (avgEAR < EAR_THRESHOLD) this.closedFrameCount++;
            else this.closedFrameCount = 0;

            if (this.closedFrameCount > SLEEP_FRAMES) return { status: "WAKE UP!", alert: true, val: avgEAR };
            return { status: "Awake", alert: false, val: avgEAR };
        }
    }
    const drowsyTracker = new DrowsinessTracker();

    // --- CORE: YOLO + TTC ---
    class RiskSmoother {
        constructor(historyLen = 3) {
            this.history = []; this.historyLen = historyLen;
            this.riskMap = { 'Safe': 0, 'Warning': 1, 'Critical': 2 };
            this.revMap = { 0: 'Safe', 1: 'Warning', 2: 'Critical' };
        }
        update(currentRisk) {
            this.history.push(this.riskMap[currentRisk]);
            if (this.history.length > this.historyLen) this.history.shift();
            const maxRiskVal = Math.max(...this.history);
            return this.revMap[maxRiskVal];
        }
    }
    const smoother = new RiskSmoother();

    class ObjectTracker {
        constructor() { this.lastHeight = 0; this.lastTime = 0; this.minGrowthRate = 0.003; }
        calculateTTC(box, timestamp) {
            const h = box[3]; // Height
            let ttc = 999.0; let risk = 'Safe';
            if (this.lastTime > 0) {
                const dt = (timestamp/1000) - (this.lastTime/1000);
                if (dt > 0.001) {
                    const dh = h - this.lastHeight;
                    if (dh/dt > this.minGrowthRate) {
                        ttc = h / (dh/dt);
                        if (ttc < TTC_THRESHOLDS.CRITICAL) risk = 'Critical';
                        else if (ttc < TTC_THRESHOLDS.WARNING) risk = 'Warning';
                    }
                }
            }
            this.lastHeight = h; this.lastTime = timestamp / 1000;
            return { ttc, risk };
        }
    }
    const tracker = new ObjectTracker();

    // --- HELPERS & AUDIO ---
    function playBeep(riskLevel) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (riskLevel === 'Critical') {
            osc.frequency.value = 800; osc.type = 'square'; gain.gain.value = 0.1;
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else if (riskLevel === 'Warning') {
            osc.frequency.value = 400; osc.type = 'sine'; gain.gain.value = 0.1;
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    }

    // --- YOLO PREPROCESS ---
    function preprocess(ctx, vw, vh) {
        // Letterboxing
        scaleFactor = Math.min(YOLO_SIZE / vw, YOLO_SIZE / vh);
        const newWidth = vw * scaleFactor;
        const newHeight = vh * scaleFactor;
        xOffset = (YOLO_SIZE - newWidth) / 2;
        yOffset = (YOLO_SIZE - newHeight) / 2;

        tempCtx.fillStyle = "black";
        tempCtx.fillRect(0, 0, YOLO_SIZE, YOLO_SIZE);
        tempCtx.drawImage(video, xOffset, yOffset, newWidth, newHeight);

        const imageData = tempCtx.getImageData(0, 0, YOLO_SIZE, YOLO_SIZE);
        const { data } = imageData;
        const totalPixels = YOLO_SIZE * YOLO_SIZE;
        for (let i = 0; i < totalPixels; i++) {
            float32Data[i] = data[i * 4] / 255.0;                      
            float32Data[i + totalPixels] = data[i * 4 + 1] / 255.0;   
            float32Data[i + 2 * totalPixels] = data[i * 4 + 2] / 255.0; 
        }
        return new ort.Tensor('float32', float32Data, [1, 3, YOLO_SIZE, YOLO_SIZE]);
    }

    function iou(box1, box2) {
        const [x1, y1, w1, h1] = box1; const [x2, y2, w2, h2] = box2;
        const xi1 = Math.max(x1, x2); const yi1 = Math.max(y1, y2);
        const xi2 = Math.min(x1 + w1, x2 + w2); const yi2 = Math.min(y1 + h1, y2 + h2);
        const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
        return interArea / ((w1 * h1) + (w2 * h2) - interArea);
    }

    function nms(boxes) {
        if (boxes.length === 0) return [];
        boxes.sort((a, b) => b.prob - a.prob);
        const picked = []; const active = new Array(boxes.length).fill(true);
        for (let i = 0; i < boxes.length; i++) {
            if (!active[i]) continue;
            const boxA = boxes[i]; picked.push(boxA);
            for (let j = i + 1; j < boxes.length; j++) {
                if (!active[j]) continue;
                if (iou(boxA.box, boxes[j].box) > IOU_THRESHOLD) active[j] = false;
            }
        }
        return picked;
    }

    function postprocess(output) {
        const data = output.data; const boxes = []; const num_anchors = 8400; 
        for (let i = 0; i < num_anchors; i++) {
            let maxScore = -Infinity; let maxClass = -1;
            for (let c = 4; c < 84; c++) {
                const score = data[c * num_anchors + i]; 
                if (score > maxScore) { maxScore = score; maxClass = c - 4; }
            }
            if (maxScore > CONFIDENCE_THRESHOLD) {
                const x = data[0 * num_anchors + i]; const y = data[1 * num_anchors + i];
                const w = data[2 * num_anchors + i]; const h = data[3 * num_anchors + i];
                // REVERSE LETTERBOXING
                let x1 = x - w/2; let y1 = y - h/2;
                x1 = x1 - xOffset; y1 = y1 - yOffset;
                x1 = x1 / scaleFactor; y1 = y1 / scaleFactor;
                let w_scaled = w / scaleFactor; let h_scaled = h / scaleFactor;
                boxes.push({ label: LABELS[maxClass], prob: maxScore, box: [x1, y1, w_scaled, h_scaled] });
            }
        }
        return nms(boxes);
    }

    // --- MAIN LOOP ---
    async function runRoadInference() {
        if (currentMode !== 'road') return;
        
        ctx.drawImage(video, 0, 0, DISPLAY_W, DISPLAY_H);
        
        if (cvLoaded) {
            const laneStatus = laneTracker.detect(ctx, canvas.width, canvas.height);
            auxEl.innerText = laneStatus;
            
            // Visual feedback for drift
            if (laneStatus.includes("Drift")) monitorContainer.classList.add('lane-drift-border');
            else monitorContainer.classList.remove('lane-drift-border');
            
            // Make text red if no lanes
            if (laneStatus === "No Lanes") auxEl.style.color = "#fbbf24"; // yellow warning
            else auxEl.style.color = "#22d3ee"; // cyan default
        }

        lastDetections.forEach(d => {
            const [x, y, w, h] = d.box;
            let color = d.risk === 'Critical' ? '#f00' : d.risk === 'Warning' ? '#ff0' : '#0f0';
            ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.strokeRect(x,y,w,h);
            ctx.fillStyle = color; ctx.fillText(d.label + " " + Math.round(d.prob*100) + "%", x, y-5);
        });

        const now = performance.now();
        if (!isProcessing && (now - lastTime > (1000 / TARGET_FPS))) {
            isProcessing = true; lastTime = now;
            try {
                // FIX: Use actual video dimensions
                const inputTensor = preprocess(video, video.videoWidth, video.videoHeight);
                const feeds = {};
                feeds[session.inputNames[0]] = inputTensor;
                const results = await session.run(feeds);
                const output = results[session.outputNames[0]];
                const boxes = postprocess(output);
                
                let primaryBox = null; let maxArea = 0;
                boxes.forEach(d => {
                    const [x, y, w, h] = d.box;
                    if (w*h > maxArea) { maxArea=w*h; primaryBox=d.box; }
                });

                let currentTTC = 999.0; let currentRisk = 'Safe';
                let speedMph = 0.0;
                if (primaryBox) {
                    const res = tracker.calculateTTC(primaryBox, now);
                    currentTTC = res.ttc; currentRisk = res.risk;
                    const expansionRate = (primaryBox[3] - tracker.lastHeight) / ((now - tracker.lastTime*1000)/1000);
                    if (expansionRate > 0) speedMph = expansionRate * 0.15;
                } else { tracker.lastHeight = 0; }

                const finalRisk = smoother.update(currentRisk);
                if (recorder) recorder.trigger(finalRisk);
                
                boxes.forEach(b => b.risk = finalRisk);
                lastDetections = boxes;

                ttcEl.innerText = currentTTC >= 900 ? "--" : currentTTC.toFixed(1);
                riskEl.innerText = finalRisk;
                speedEl.innerText = speedMph.toFixed(1) + " MPH";
                
                alertEl.style.display = 'none';
                monitorContainer.classList.remove('critical-border', 'warning-border', 'safe-border');

                if (finalRisk === 'Critical') {
                    monitorContainer.classList.add('critical-border');
                    alertEl.style.display = 'block'; alertEl.innerText = "CRITICAL WARNING"; alertEl.style.color="red";
                    playBeep('Critical');
                } else if (finalRisk === 'Warning') {
                    monitorContainer.classList.add('warning-border');
                    alertEl.style.display = 'block'; alertEl.innerText = "WARNING"; alertEl.style.color="yellow";
                    playBeep('Warning');
                } else {
                    monitorContainer.classList.add('safe-border');
                }

            } catch(e) { } finally { isProcessing = false; }
        }
        
        frameCount++;
        if (performance.now() - lastFpsTime >= 1000) { 
            fpsCounterEl.innerText = frameCount; frameCount = 0; lastFpsTime = performance.now(); 
        }
        
        requestAnimationFrame(runRoadInference);
    }

    // --- FACE MESH LOGIC ---
    async function initFaceMesh() {
        if (faceMesh) return;
        statusTextEl.innerText = "Loading Face Mesh...";
        faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        faceMesh.onResults(onFaceResults);
        await faceMesh.initialize();
        statusTextEl.innerText = "Active";
    }

    function onFaceResults(results) {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        const result = drowsyTracker.process(results);
        ttcEl.innerText = result.val ? result.val.toFixed(2) : '--'; 
        riskEl.innerText = result.status;
        auxEl.innerText = "Tracking Eyes";
        if (result.alert) {
            alertEl.style.display = 'block'; alertEl.innerText = result.status; alertEl.style.color = "red";
            playBeep('Critical');
        } else { alertEl.style.display = 'none'; }
        ctx.restore();
    }

    async function runDriverInference() {
        if (currentMode !== 'driver') return;
        await faceMesh.send({image: video});
        requestAnimationFrame(runDriverInference);
    }

    // --- SWITCH MODES ---
    // FIXED: Updated IDs from underscores to hyphens and used 'mode-active' class
    window.switchMode = async function(mode) {
        currentMode = mode;
        document.getElementById('btn-road').className = mode === 'road' ? 'mode-btn mode-active' : 'mode-btn';
        document.getElementById('btn-driver').className = mode === 'driver' ? 'mode-btn mode-active' : 'mode-btn';
        const constraints = { video: { width: DISPLAY_W, height: DISPLAY_H, facingMode: mode === 'road' ? 'environment' : 'user' } };
        if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.onloadedmetadata = async () => {
            video.play();
            if (mode === 'road') {
                canvas.style.transform = "scaleX(1)";
                runRoadInference();
            } else {
                canvas.style.transform = "scaleX(-1)";
                await initFaceMesh();
                runDriverInference();
            }
        };
    }

    // --- INITIALIZATION ---
    async function main() {
        try {
            statusTextEl.innerText = "Loading AI...";
            
            // 1. Check for Model 404
            const resp = await fetch(MODEL_PATH);
            if (!resp.ok) throw new Error("yolov8n.onnx not found! Check file.");
            
            if (typeof ort === 'undefined') throw new Error("ONNX Runtime failed.");
            ort.env.logLevel = 'error';
            
            session = await ort.InferenceSession.create(MODEL_PATH, { executionProviders: ['wasm'] });
            
            recorder = new IncidentRecorder(canvas); // INIT RECORDER HERE
            
            window.switchMode('road');
            statusTextEl.innerText = "Active";
            statusTextEl.style.color = "#0f0";

        } catch (e) {
            statusTextEl.innerText = "Error"; statusTextEl.style.color = "red"; console.error(e.message); 
        }
    }
    
    // --- FIREBASE ---
    window.setupFirebase = async function() {
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = {}; try { firebaseConfig = JSON.parse(__firebase_config); } catch {}
        if (firebaseConfig.projectId) {
            const app = initializeApp(firebaseConfig); db = getFirestore(app); auth = getAuth(app);
            try { await signInAnonymously(auth); 
                onAuthStateChanged(auth, (u) => { if(u) { 
                    userId=u.uid; document.getElementById('user-id-display').textContent=userId.substring(0,6); 
                    onSnapshot(doc(db, `artifacts/${appId}/users/${userId}/settings`, 'adas_config'), (snap) => {
                        if (snap.exists()) {
                            const s = snap.data();
                            TTC_THRESHOLDS.CRITICAL = s.critical_ttc;
                            TTC_THRESHOLDS.WARNING = s.warning_ttc;
                        }
                    });
                } });
            } catch (e) {}
        }
    }
    
    window.saveUserSettings = async function() {
        const btn = document.getElementById('save-settings-btn');
        const originalText = btn.innerText;
        btn.innerText = "Saved!";
        setTimeout(() => btn.innerText = originalText, 2000);
        TTC_THRESHOLDS.CRITICAL = parseFloat(document.getElementById('critical-input').value);
        TTC_THRESHOLDS.WARNING = parseFloat(document.getElementById('warning-input').value);
        if (firebaseReady) {
            try {
                await setDoc(doc(db, `artifacts/${typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'}/users/${userId}/settings`, 'adas_config'), {
                    critical_ttc: TTC_THRESHOLDS.CRITICAL, warning_ttc: TTC_THRESHOLDS.WARNING
                }, { merge: true });
            } catch (e) {}
        }
    }

    document.getElementById('save-settings-btn').addEventListener('click', window.saveUserSettings);
    document.addEventListener('DOMContentLoaded', () => { window.setupFirebase(); window.onload = main; });

</script>
</body>
</html>
